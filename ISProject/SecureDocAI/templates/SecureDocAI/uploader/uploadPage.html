{% extends "SecureDocAI/uploader/layout.html" %}
{% load static %}  <!-- Make sure this is at the top -->

{% block title %}SecureDocAI - UploadDocument{% endblock %}

{% block content %}

<style>
    .btn-link {
    display: inline-block;
    padding: 10px 20px;
    margin-top: 10px;
    color: white;
    background-color: #6277b8;
    border-radius: 5px;
    text-decoration: none;
    font-weight: 600;
    transition: background-color 0.3s ease, transform 0.2s ease;
    box-shadow: 0 4px 6px rgba(0,0,0,0.1);
}

.btn-link:hover {
    background-color: #45a049;
    transform: translateY(-2px);
}

.btn-link:active {
    transform: scale(0.98);
}

.btn-link.disabled {
    pointer-events: none;
    background-color: #aaa;
    cursor: default;
}


a {
    text-decoration: none;
}

/* Navigation styles */
.main-nav {
    background-color: white;
    border-bottom: 1px solid #e5e7eb;
}

.nav-links {
    display: flex;
    justify-content: center;
}

.nav-link {
    padding: 1rem 1.5rem;
    color: #4b5563;
    text-decoration: none;
    font-weight: 500;
    border-bottom: 2px solid transparent;
    transition: all 0.2s ease;
}

.nav-link:hover {
    color: #2563eb;
    border-bottom-color: #2563eb;
}

.nav-link.active {
    color: #2563eb;
    border-bottom-color: #2563eb;
}
</style>

<nav class="main-nav">
    <div class="container">
        <div class="nav-links">
            <a href="{% url 'uploader_dashboard' %}" class="nav-link active">Upload Documents</a>
            <a href="{% url 'uploaderViewDocument' %}" class="nav-link">View Documents</a>
            <a href="{% url 'uploaderAccesslog' %}" class="nav-link">Access log</a>
        </div>
    </div>
</nav>

<main class="container">

    <section class="upload-section">
        <h2><i data-lucide="upload"></i> Upload Document</h2>


        <form id="uploadForm" class="upload-form" method="POST" enctype="multipart/form-data">

            {% csrf_token %}
            <div class="form-group">
                <label for="title">Document Title</label>
                <input type="text" id="title" name='title' required>
            </div>

            <div class="form-group">
                <label for="description">Description</label>
                <textarea id="description" rows="3" name='description' required ></textarea>
            </div>

            <div class="form-group">
                <label>Upload File</label>
                <div class="file-upload">
                    <i data-lucide="upload" class="upload-icon"></i>
                    <span id="fileName">Click to upload or drag and drop</span>
                    <input type="file" id="fileInput" name="file" required>
                </div>
            </div>
            <!-- Add a hidden field for encrypted AES key -->
            <input type="hidden" id="encryptedAESKey" name="encrypted_aes_key">
            <input type="hidden" id="encryptedMetadata" name="encrypted_metadata">
            <input type="hidden" id="classification" name="classification">
            <input type="hidden" id="rsaPublicKey" value="{{ key }}">
            <input type="hidden" id="signature" name="signature">
            <input type="hidden" id="signingPublicKey" name="signingPublicKey"> <!-- FIXED -->                


            <button type="submit" class="submit-btn">Upload Document</button>
        </form>
    </section>

</main>
<script>lucide.createIcons();</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>

<!-- Configure PDF.js worker -->
<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';
</script>

<script>
document.getElementById('uploadForm').addEventListener('submit', async function(e) {
    e.preventDefault();

    const fileInput = document.getElementById('fileInput');
    const file = fileInput.files[0];

    if (!file || file.type !== 'application/pdf') {
        alert('Please select a valid PDF file.');
        return;
    }

    const title = document.getElementById('title').value;
    const rsaPublicKey = document.getElementById('rsaPublicKey').value;

    // Step 1: Extract text from PDF
    const extractedText = await extractTextFromPDF(file);

    // Step 2: Classify content
    const classification = mockAIClassification(extractedText);
    document.getElementById('classification').value = classification;

    // Step 3: Generate AES key
    const aesKey = window.crypto.getRandomValues(new Uint8Array(32));

    // Step 4: Encrypt PDF content with AES
    const fileBuffer = await file.arrayBuffer();
    const encryptedFileBuffer = await aesEncrypt(fileBuffer, aesKey);

    const encryptedBlob = new Blob([encryptedFileBuffer], { type: 'application/octet-stream' });
    const dataTransfer = new DataTransfer();
    dataTransfer.items.add(new File([encryptedBlob], file.name));
    fileInput.files = dataTransfer.files;

    // Step 5: Encrypt AES key using RSA public key
    const encryptedAESKey = encryptWithRSA(rsaPublicKey, aesKey);
    document.getElementById('encryptedAESKey').value = btoa(encryptedAESKey);

    // Step 6: Encrypt metadata
    const metadata = JSON.stringify({ name: file.name, type: file.type });
    const metadataBytes = new TextEncoder().encode(metadata);
    const encryptedMetadataBuffer = await aesEncrypt(metadataBytes, aesKey);
    document.getElementById('encryptedMetadata').value = btoa(String.fromCharCode(...new Uint8Array(encryptedMetadataBuffer)));

    // Step 7: RSA Signing
    const keyPair = await generateRSAKeyPair();
    const messageToSign =  title;
    const signatureBuffer = await signData(keyPair.privateKey, messageToSign);
    const signatureB64 = btoa(String.fromCharCode(...new Uint8Array(signatureBuffer)));
    document.getElementById('signature').value = signatureB64;

    const publicKeyB64 = await exportPublicKey(keyPair.publicKey);
    document.getElementById('signingPublicKey').value = publicKeyB64;

    // Submit the form now that everything is processed
    this.submit();
});

// ---------------------- Helper Functions ----------------------

async function extractTextFromPDF(file) {
    const arrayBuffer = await file.arrayBuffer();
    const pdf = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    let text = '';
    for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const content = await page.getTextContent();
        text += content.items.map(item => item.str).join(' ') + '\n';
    }
    return text;
}

function mockAIClassification(text) {
    if (text.toLowerCase().includes("invoice")) return "Finance";
    if (text.toLowerCase().includes("project")) return "Engineering";
    return "General";
}

async function aesEncrypt(data, key) {
    const iv = window.crypto.getRandomValues(new Uint8Array(12));
    const cryptoKey = await window.crypto.subtle.importKey("raw", key, "AES-GCM", false, ["encrypt"]);
    const encrypted = await window.crypto.subtle.encrypt({ name: "AES-GCM", iv }, cryptoKey, data);
    const combined = new Uint8Array(iv.length + encrypted.byteLength);
    combined.set(iv);
    combined.set(new Uint8Array(encrypted), iv.length);
    return combined;
}

function encryptWithRSA(publicKeyPem, aesKey) {
    const forge = window.forge;
    const publicKey = forge.pki.publicKeyFromPem(publicKeyPem);
    const encrypted = publicKey.encrypt(forge.util.binary.raw.encode(aesKey), 'RSA-OAEP');
    return encrypted;
}

// --- RSA instead of DSA ---
async function generateRSAKeyPair() {
    return await window.crypto.subtle.generateKey(
        {
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: 2048,
            publicExponent: new Uint8Array([1, 0, 1]),
            hash: "SHA-256",
        },
        true,
        ["sign", "verify"]
    );
}

async function signData(privateKey, data) {
    const encoded = new TextEncoder().encode(data);
    return await window.crypto.subtle.sign({ name: "RSASSA-PKCS1-v1_5" }, privateKey, encoded);
}

async function exportPublicKey(key) {
    const exported = await window.crypto.subtle.exportKey("spki", key);
    return btoa(String.fromCharCode(...new Uint8Array(exported)));
}
</script>

{% endblock %}
